#include "global.h"
#include "reg.h"
#include <intrins.h>

#define TIM0_INTERVAL (50000) // 大约 100 时还能正常运行相当于时钟 500 倍加速
#define TIM1_INTERVAL (10000) // 大约 100 时还能正常运行相当于时钟 500 倍加速

// 中断服务函数,用于 Timer 0，目标是产生 1Hz 的中断
void Timer0_ISR() interrupt 1
{
	static unsigned int count_1 = 0; // 静态变量，用于计数 Timer 0 中断发生的次数，用于实现更长时间的定时

	// 重新加载 Timer 0 的高 8 位寄存器 TH0
	// 65536 是 16 位定时器的最大值
	// 50000 是我们希望定时器计数的次数
	// 晶振频率 12MHz，一个机器周期是 12/12 = 1us
	// 定时器工作在 12 分频模式下，定时器计数频率为 1MHz
	// 要定时 50ms (0.05s)，需要计数 0.05s * 1000000 次/s = 50000 次
	TH0 = (65536 - TIM0_INTERVAL) / 256;

	// 重新加载 Timer 0 的低 8 位寄存器 TL0
	TL0 = (65536 - TIM0_INTERVAL) % 256;

	count_1++; // 每次进入中断，计数器加 1

	if(count_1 >= 20) // 当计数器达到 20 时，说明已经过了 20 * 50ms = 1000ms = 1秒
	{
		count_1 = 0;       // 计数器清零，为下一次 1 秒计时做准备
		second_1 = ~second_1; // 将全局变量 second_1 的值翻转，用于指示 1 秒已过 (例如，用于 LED 闪烁)
	}
}

// 初始化 Timer 0
void Timer0_Init() {
	// 配置 TMOD 寄存器，设置 Timer 0 的工作模式
	// TMOD 的低 4 位控制 Timer 0
	// 0x01 表示：
	// GATE(位 0) = 0，定时器启动与外部引脚无关
	// C/T'(位 1) = 0，选择定时器模式 (对机器周期计数)
	// M1M0(位 3, 位 2) = 01，选择工作模式 1 (16 位定时器)
	TMOD |= 0x01;

	// 设置 Timer 0 的初始值，以实现 50ms 的定时
	// 计算方法与中断服务函数中相同
	TH0 = (65536 - TIM0_INTERVAL) / 256;
	TL0 = (65536 - TIM0_INTERVAL) % 256;

	EA = 1;  	// 开总中断，允许所有中断
	ET0 = 1; 	// 开 Timer 0 中断允许位，允许 Timer 0 的中断请求
	TR0 = 1; 	// 启动 Timer 0，使定时器开始计数
}

// Timer 1 中断服务函数
void Timer1_ISR() interrupt 3  // Timer 1 的中断号是 3
{
	// 重新加载定时器 1 的高 8 位寄存器 TH1
	// 65536 是 16 位定时器的最大值
	// 10000 是我们希望定时器计数的次数，以实现 10ms 的定时
	// 晶振频率 12MHz，定时器计数频率为 1MHz
	// 要定时 10ms (0.01s)，需要计数 0.01s * 1000000 次/s = 10000 次
	TH1 = (65536 - TIM1_INTERVAL) / 256; // 计算并加载 TH1 的值

	// 重新加载定时器 1 的低 8 位寄存器 TL1
	TL1 = (65536 - TIM1_INTERVAL) % 256; // 计算并加载 TL1 的值

	RefreshSEG7(); 			// 执行数码管刷新函数，在每次 Timer 1 中断时刷新数码管显示，实现动态扫描
}

// 初始化 Timer 1
void Timer1_Init()
{
	// 配置 TMOD 寄存器，设置定时器 1 的工作模式
	// TMOD 的高 4 位控制定时器 1
	// 0x10 表示：
	// GATE(位 4) = 0，定时器启动与外部引脚无关
	// C/T'(位 5) = 0，选择定时器模式 (对机器周期计数)
	// M1M0(位 7, 位 6) = 01，选择工作模式 1 (16 位定时器)
	TMOD |= 0x10;

	// 计算 10ms 定时的初值，并加载到 TH1 和 TL1
	TH1 = (65536 - TIM1_INTERVAL) / 256;
	TL1 = (65536 - TIM1_INTERVAL) % 256;

	ET1 = 1;   	// 使能 Timer 1 中断允许位，允许定时器 1 的中断请求
	TR1 = 1;   	// 启动 Timer 1，使定时器开始计数
	EA = 1;		// 总中断使能 (如果还没使能)，确保允许中断发生
}

// 暂停 Timer 1 中断
void PauseTimer1Interrupt() {
	ET1 = 0; // 清除 ET1 位 (Timer 1 中断允许位)，禁止 Timer 1 中断
}

// 恢复 Timer 1 中断
void ResumeTimer1Interrupt() {
	ET1 = 1; // 设置 ET1 位 (Timer 1 中断允许位)，允许 Timer 1 中断
}

/*
 * 定时器的工作模式：
 * 8051 系列单片机有 4 种定时器/计数器的工作模式，通过 TMOD 寄存器的 M1 和 M0 位进行选择。
 *
 * 模式 0 (M1M0 = 00)：8 位定时器/计数器，带 8 位预分频器。
 *   - THx 构成 8 位计数器，TLx 构成 5 位预分频器。
 *   - 当 TLx 溢出时，THx 计数器加 1。
 *   - 当 THx 溢出时，产生定时器中断。
 *   - 实际是 13 位定时器。
 *
 * 模式 1 (M1M0 = 01)：16 位定时器/计数器。
 *   - THx 和 TLx 构成一个 16 位的计数器。
 *   - 计数范围从 0x0000 到 0xFFFF。
 *   - 当计数器从 0xFFFF 溢出回到 0x0000 时，产生定时器中断。
 *   - 这是代码中使用的模式。
 *
 * 模式 2 (M1M0 = 10)：8 位自动重载定时器/计数器。
 *   - TLx 作为 8 位计数器。
 *   - THx 存放一个 8 位的重载值。
 *   - 当 TLx 溢出时，产生定时器中断，并且 THx 的值会自动加载到 TLx，无需软件重新加载初始值。
 *   - 适用于需要精确且周期性定时或计数的情况。
 *
 * 模式 3 (M1M0 = 11)：定时器/计数器 0 分裂为两个 8 位定时器/计数器。（定时器/计数器 1 在此模式下停止工作）
 *   - TL0 可以作为一个 8 位定时器或计数器，它的控制位是 T0 的控制位。
 *   - TH0 只能作为一个 8 位定时器，它的时钟源固定为机器周期，并且只能通过 TR1 (定时器 1 的运行控制位) 启动和停止。
 *   - 这种模式常用于需要额外 8 位定时器的情况。
 *
 * 计数器如何设置和计算 (以代码中的模式 1 为例)：
 *
 * 晶振频率：12 MHz
 * 机器周期：12 / 12 = 1 微秒 (通常 8051 单片机的定时器/计数器以 12 分频的机器周期计数，所以定时器计数频率是晶振频率的 1/12)
 * 定时器计数频率：1 MHz (1 微秒计数一次)
 *
 * 目标定时时间：根据需要设置，例如代码中 Timer 0 目标是 50ms，Timer 1 目标是 10ms。
 *
 * 计算需要计数的次数：
 *   计数次数 = 目标定时时间 / 定时器计数周期
 *
 *   对于 Timer 0 (目标 50ms)：
 *   计数次数 = 0.05 秒 / 0.000001 秒 = 50000
 *
 *   对于 Timer 1 (目标 10ms)：
 *   计数次数 = 0.01 秒 / 0.000001 秒 = 10000
 *
 * 计算定时器初始值：
 *   由于定时器是递增计数，从设置的初始值开始计数到 65535 (0xFFFF) 后溢出产生中断。
 *   为了在达到目标时间时产生中断，我们需要设置一个合适的初始值，使得从这个初始值开始计数到溢出的次数正好是需要的计数次数。
 *
 *   初始值 = 65536 - 需要计数的次数
 *
 *   对于 Timer 0：
 *   初始值 = 65536 - 50000 = 15536
 *
 *   将 16 位初始值分解为高 8 位和低 8 位：
 *   TH0 = 15536 / 256 = 60 (0x3C)
 *   TL0 = 15536 % 256 = 176 (0xB0)
 *   因此代码中 `TH0 = (65536 - 50000) / 256;` 和 `TL0 = (65536 - 50000) % 256;`
 *
 *   对于 Timer 1：
 *   初始值 = 65536 - 10000 = 55536
 *
 *   将 16 位初始值分解为高 8 位和低 8 位：
 *   TH1 = 55536 / 256 = 217 (0xD9)
 *   TL1 = 55536 % 256 = 96 (0x60)
 *   因此代码中 `TH1 = (65536 - 10000) / 256;` 和 `TL1 = (65536 - 10000) % 256;`
 *
 * 总结：通过计算需要的计数次数，然后用 65536 减去这个次数，得到定时器的初始值，再将初始值分解为高低字节分别加载到 THx 和 TLx 寄存器中，就可以实现精确的定时。
 */